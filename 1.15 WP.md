## [MoeCTF 2022]寻找黑客的家


大黑客Mikato期末结束就迫不及待的回了家，并在朋友圈发出了“这次我最早”的感叹。那么你能从这条朋友圈找到他的位置吗？
moectf{照片拍摄地市名区名路名} (字母均小写)
例如：西安市长安区西沣路：moectf{xian_changan_xifeng}

解压缩得到两张图片，看到显眼的“汉明宫足疗”，用百度地图搜索得到

![alt text](8241c441f56a3edf787739fc4ff8625.jpg)

查看联系电话，尾号一致
![alt text](bfe298c300e1a76e213bfa6774b1899.jpg)

用百度地图全景功能查看周围布置一样
![alt text](e1e810a345c1408b7da17c8a3121ef1.jpg)

*NSSCTF{shenzhen_longhua_qingquan}*

## [MoeCTF 2022]zip套娃

伪加密
密码爆破
掩码攻击


题目描述
zip套娃娃娃

解压缩得到一个加密压缩包和一个加密文档，用apchpr进行爆破尝试，得到密码1235，成功解压压缩包

![alt text](<屏幕截图 2025-02-10 090338.png>)

![alt text](<屏幕截图 2025-02-10 093417.png>)

得到新的压缩包，用010 editor打开发现存在伪加密

伪加密相关知识
https://www.cnblogs.com/0yst3r-2046/p/11890498.html

要修改发现无权限，查看之后是apchpr占用了，关闭之后有读写权限

![alt text](<屏幕截图 2025-02-10 095042.png>)

![alt text](<屏幕截图 2025-02-10 095857.png>)

修改后保存即可打开文件得到flag

![alt text](<屏幕截图 2025-02-10 103113.png>)
 
 *moectf{!zip_qwq_ZIP}*
## [FSCTF 2023]最终试炼hhh

PDF隐写
伪加密
压缩包分析

题目描述
李华早起发现现在居然是黑天！

解压发现一个无后缀文件，将其放入010 editor发现有04 03 4B 50，尝试倒置该文件

input = open('./flag1', 'rb')
input_all = input.read()
ss = input_all[::-1]
output = open('./flag.zip', 'wb')
output.write(ss)
input.close()
output.close()

发现伪加密，更改后得到flag

![alt text](<屏幕截图 2025-02-10 120931.png>)

*FSCTF{cmdgy_yyds}*

## [网鼎杯 2022 玄武组]misc999

编码分析
字符编码
MISC


题目描述
base

得到一串密码表和一串密文，密码表62位，尝试base62解密

![alt text](<屏幕截图 2025-02-11 083653.png>)
得到flag

*flag{cf492422-13cb-4123-8bc5-5495f0349494}*

## [SDCTF 2022]Case64AR

凯撒密码
Base家族
古典密码

题目描述
Someone script kiddie just invented a new encryption scheme. It is described as a blend of modern and ancient cryptographic techniques. Can you prove that the encryption scheme is insecure by decoding the ciphertext below?

Ciphertext: OoDVP4LtFm7lKnHk+JDrJo2jNZDROl/1HH77H5Xv

根据提示，先进行base64解密，看到有一部分不在base64码表，对密文在base64码表的部分进行凯撒解密与base64解密，保留其他部分

    import base64

       def create_base64_index_map():
      """创建Base64字符到其索引的映射"""
       base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
     return {char: index for index, char in enumerate(base64_chars)}

    def caesar_decrypt(ciphertext, shift, base64_index_map):
     """凯撒解密函数，使用预创建的索引映射"""
         decrypted_text = ""
         for char in ciphertext:
          if char in base64_index_map:
            original_index = base64_index_map[char]
            decrypted_index = (original_index - shift) % 64
            decrypted_text += list(base64_index_map.keys())[decrypted_index]
         else:
            decrypted_text += char  # 保留非Base64字符
         return decrypted_text

       def try_decode(ciphertext):
       """尝试不同偏移量并解码"""
          base64_index_map = create_base64_index_map()
         for shift in range(64):
         decrypted = caesar_decrypt(ciphertext, shift, base64_index_map)
          try:
            decoded = base64.b64decode(decrypted).decode('utf-8')
            print(f"Shift {shift}: {decoded}")
         except (ValueError, UnicodeDecodeError):
            continue  # 如果解码失败，跳过

     你的密文
      ciphertext = "OoDVP4LtFm7lKnHk+JDrJo2jNZDROl/1HH77H5Xv"
     try_decode(ciphertext)


得到flag

*sdctf{OBscUr1ty_a1nt_s3CURITy}*




